## 자바와 객체 지향

### 1. 객체 지향의 4대 특성
- 캡슐화
- 상속
- 추상화
- 다형성

### 1. 추상화

> 추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것이라고 정리할
> 수 있다.

객체 지향의 4대 특성은 클래스로 인해 구현된다. 객체(object)는 **유일무이한 사물**이다.
그리고 클래스는 **같은 특성을 지닌 여러 객체를 포함하는 집합의 개념**이다.

```java
public class Person {
    String name;
    String age;

    public static void main(String[] args) {
        Person kim = new Person();
        Person park = new Person();
    }
}
```

이 코드는 Person 클래스를 이용해서 kim과 park의 객체를 생성했다. 클래스를 이용해서 객체를
만들었다는 것을 강조할 때, 객체라는 표현보다는 클래스의 인스턴스(instance)라는 표현을 쓴다.
보통 클래스가 객체의 설계도라고 하는 표현은 이런 과정에서 나왔다고 보면 된다.

객체 지향 프로그래밍을 할 때 클래스를 가장 먼저 설계한다. 그리고 우리는 객체를 관찰해서 그 객체들 간의 공통된 특성을 포착해서 클래스를 설계한다.
예를 들어 Person(사람) 클래스를 만들었을 때, 이름과 나이같은 속성과 먹다(), 자다() 같은 메서드를 가질 수 있다.

여기서 중요한 것은 클래스를 설계할 때 모든 특성을 담기란 불가능하고, 또 그럴 필요도 없다.
"애플리케이션이 어디에 활용될 것인가?"에 초점을 맞춰서 필요한 특성만 담으면 된다. 즉, 필요한
특성의 **경계**가 필요한데, 이것을 **애플리케이션 경계** 또는 **컨텍스트(Context)** 라고 부른다.

> 내용을 정리하면 추상화는 구체적인 것을 분해해서 **관심 영역**에 있는 특성만 가지고 재조합하는 것이라고
> 설명이 가능하다.

그리고 이러한 추상화의 개념은 모델링의 개념과 동일하다. 모델은 실제 사물을 정확하게 복제하는 것이 아니라
관심 있는 특성만을 추출해서 표현하는 것이기 때문이다. 

그래서 추상화를 요약하면 다음과 같다.
- 객체 지향 프로그래밍에서 **추상화는 모델링**이다.
- 클래스를 설계할 때, **애플리케이션 경계(Context)** 부터 정해야 한다.
- 객체 지향에서 추상화의 결과는 클래스이다.

### 2. 클래스 멤버 vs 객체 멤버

객체들이 여러개 있을 때, 그 객체들 간의 공통 속성이 있다면 따로 빼는 것이 관리하기 편하고 메모리도 절약할 수 있다.
예를 들어, 호랑이라는 클래스를 설계했을 때 기본적으로 호랑이의 다리는 4개이다. 이것을 각 객체별로
속성을 지정하는 것보단, 어느 한 곳에 저장해놓고 공통적으로 사용하는 게 편하다.

이 때 사용되는 것이 static 키워드이다. static 키워드를 속성 앞에 붙이면 그 멤버는 **클래스 멤버**가 된다.
그리고 클래스 멤버는 자바의 T 메모리의 static 영역에 단 하나의 저장 공간을 갖게 된다.
static이 안 붙은 속성을 **객체 멤버**라고 부른다. 즉, static 키워드가 붙었냐 안 붙었냐를 기준으로
클래스 멤버와 객체 멤버를 나눌 수 있다. 이는 메서드도 마찬가지다.

```java
public static void main(String[] args){}
```

Java 애플리케이션에서 가장 먼저 볼 수 있는 main 메서드 앞에도 static 키워드가 붙어 있는데,
main 메서드 역시 클래스 멤버 메서드이기 때문이다. 클래스 멤버 메서드를 정적 메서드라고도 부른다.
main 메서드는 반드시 정적 메서드여야 한다. 그 이유는 T 메모리가 초기화됐을 때 객체 멤버 메서드를 바로 실행할 수
없기 때문이다.

> Note. 스프링을 공부하다보면 다음과 같은 용어를 섞어쓰지만, 모두 같은 뜻이다.
- 정적 멤버, 클래스 멤버, 스태틱 멤버
- 객체 멤버, 오브젝트 멤버, 인스턴스 멤버
- 필드, 속성, 프로퍼티(Property)

#### 2.1 변수의 초기화

다음 코드는 컴파일 에러가 발생한다.
```java
public class Mouse {
    public String name;
    public int age;
    public static int countOfTail = 1;

    public void sing(){
        System.out.println(name + " 찍찍!!!");
    }

    public static void main(String[] args) {
        String localVariable;
        System.out.println(localVariable); // 컴파일 에러

        Mouse m = new Mouse();
        m.sing();
    }
}
```
**localVariable** 은 지역 변수이고 Mouse 클래스 안의 **name** 은 멤버 변수이다.
컴파일 에러가 발생하는 줄을 주석 처리하고 코드를 실행하면 출력값은 다음과 같다.
> null 찍찍!!!

클래스 속성과 객체 속성은 따로 초기화하지 않아도 정수형은 0, 부동소수점형은 0.0,
논리형은 false, 객체는 null로 초기화된다. 하지만 지역 변수는 초기화하지 않으면 그 값을 사용하고자
할 때 컴파일 에러가 발생한다.

> 이유는 멤버 변수는 **공유 변수의 성격**을 가지고 있기 때문이다.

객체 변수는 하나의 객체 안에서 다수의 객체 메서드를 공유한다.
그리고 클래스 변수는 전역 변수로서 프로그램 어디서든 접근 가능하다. 그렇다면 공유 변수는 어디서
초기화를 진행해야 할까? 주로 객체 멤버는 생성자로, static 멤버는 static 실행 영역을 통해 초기화하지만,
공유 변수를 딱히 누군가 초기화해야한다고 규정할 수는 없다. 그래서 공유 변수는 별도로 값을 지정하지 않으면
시스템에서 정한 기본값으로 초기화된다. 반면 지역 변수는 그 지역에서만 사용되는 변수이기 때문에 그 지역에서 초기화하는 것이
논리적으로 맞다.






